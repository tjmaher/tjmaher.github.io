Let's say you wanted to fill out the Billing Address of a form that has the following fields:<br /><ul><li>Name</li><li>Street Address 1&nbsp;</li><li>Street Address 2</li><li>City</li><li>State</li><li>ZipCode</li><li>Country</li></ul><br />If you wanted to store this information into an Address object, the class could look like:<br /><br /><b>Address.java:</b><br /><pre class="brush: java">     <br /><br />public class Address {<br /><br />  private String name;<br />  private String streetAddress1;<br />  private String streetAddress2;<br />  private String city;<br />  private String state;<br />  private String zipCode;<br />  private String country;<br />  <br />}<br /><br /></pre>How would we set these fields? <br /><br /><a name='more'></a><br /><br /><h2>Exploration: Using Constructors</h2><br />If we wanted to feed an address such as the one below into an object called <b>Address</b>:<br /><br />FITBIT<br />ONE MARINA PARK DRIVE<br />BOSTON, MA 02210<br />UNITED STATES<br /><br />... we could create a constructor that looks like...<br /><br /><pre class="brush: java"> <br /><br />public class Address {<br /><br />  private String name;<br />  private String streetAddress1;<br />  private String streetAddress2;<br />  private String city;<br />  private String state;<br />  private String zipCode;<br />  private String country;<br /><br />  Address ( String name, String streetAddress1, String city,<br />            String state, String zipCode, String country){<br />    this.name = name;<br />    this.streetAddress1 = streetAddress1;<br />    this.city = city;<br />    this.state = state;<br />    this.zipCode = zipCode;<br />    this.country = country;<br />  }<br />}<br /></pre><br />But what if we wanted to add a suite to the address, to make it more accurate?<br /><br />FITBIT<br />ONE MARINA PARK DRIVE<br />SUITE 701 BOSTON, MA 02210<br />UNITED STATES<br /><br />Our entire class now would look like: <br /><pre class="brush: java"> <br /><br />public class Address {<br /><br />  private String name;<br />  private String streetAddress1;<br />  private String streetAddress2;<br />  private String city;<br />  private String state;<br />  private String zipCode;<br />  private String country;<br /><br />  // First Constructor Type: Used When there is only one Address<br />  Address ( String name, String streetAddress1, String city,<br />            String state, String zipCode, String country){<br />    this.name = name;<br />    this.streetAddress1 = streetAddress1;<br />    this.city = city;<br />    this.state = state;<br />    this.zipCode = zipCode;<br />    this.country = country;<br />  }<br /><br />  // Second Constructor Type: Used When there is Address1 and Address2.<br />  Address ( String name, String streetAddress1, String streetAddress2,<br />            String city, String state, String zipCode, String country){<br />    this.name = name;<br />    this.streetAddress1 = streetAddress1;<br />    this.streetAddress2 = streetAddress2;<br />    this.city = city;<br />    this.state = state;<br />    this.zipCode = zipCode;<br />    this.country = country;<br />  }<br />}<br /><br /></pre><br /><h2>Problem One: Duplication of Code</h2><br />Yes, this is allowed in Java. It is calling <b>Overloading the Method</b>. ( <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/methods.html">Example</a> )<br /><br />One problem is that the code is not as clean as it could be... We are no longer following the main rule of software development: <b>Don't Repeat Yourself</b> ( The <a href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself">DRY</a> principle ).<br /><br />What about if we wanted to mail a package from a warehouse in the Unites States to someone in the United States? We wouldn't need to fill out the country... would we need to create yet another overloaded constructor for the country?<br /><br /><pre class="brush: java"> <br /><br />// Third Constructor Type: Used Within Same Country<br />Address ( String name, String streetAddress1, String streetAddress2,<br />            String city, String state, String zipCode){<br /></pre><br />We can see that the other problem is that the <i>signature</i> of the Constructor method grows each time the method is overloaded, with even more duplicated code. It becomes a <i>telescoping constructor</i>. <br /><br /><h2>Problem Two: Possible Confusion of Variable Order</h2><br />Take a look at the following address:<br /><br />Mr. Address Argentine<br />Piedras No 623  <br />Piso2 Dto.4    <br />C1070AAM Capital Federal<br />ARGENTINA <br /><br />The US Format is: <br /><ul><li>City</li><li>State</li><li>Zip</li><li>Country <i>( optional in the US )</i></li></ul><br />Argentina ( and many other formats ) are  <br /><ul><li>Postal Code</li><li>City/town/locality</li><li>Country</li></ul>These constructors allow you to enter values in the completely wrong order. <br /><br /><pre class="brush: java"> <br /><br />// Correct Format<br />Address billingAddress = new Address(<br />     "FITBIT", "ONE MARINA PARK DRIVE",<br />     "SUITE 701",<br />     "BOSTON", "MA", "02210", "United States");<br /><br />// X INCORRECT FORMAT, but LEGAL!!!<br />Address shippingAddreess = new Address(<br />     "Mr. Address Argentine",<br />     "Piedras No 623",<br />     "Piso2 Dto.4",    <br />     "C1070AAM", "Capital Federal",<br />     "ARGENTINA"); <br /><br /></pre><br />To demonstrate what is happening, let's take a step back to figure out how to print the contents of the Address class. <br /><br /><b>Overriding</b> the <i>toString</i> method that allows us to print to the console.<br /><br /><pre class="brush: java"> <br /><br />  @Override<br />  public String toString() {<br />    return "Name: " + this.name + "\n"<br />        + "Address1: " + this.streetAddress1 + "\n"<br />        + "Address2: " + this.streetAddress2 + "\n"<br />        + "City: " + this.city + "\n"<br />        + "State: " + this.state + "\n"<br />        + "Zip: " + this.zipCode + "\n"<br />        + "Country: " + this.country + "\n";<br />  }<br /><br /></pre><br />Now, we can create a test that demonstrate what is happening:<br /><br /><pre class="brush: java"> <br /><br />  @Test<br />  public static void testAssigningAddresses() {<br />    Address billingAddress = new Address(<br />        "FITBIT", "ONE MARINA PARK DRIVE",<br />        "SUITE 701",<br />        "BOSTON", "MA", "02210", "United States");<br />    System.out.println(billingAddress);<br /><br />    Address shippingAddress = new Address(<br />        "Mr. Address Argentine",<br />        "Piedras No 623",<br />        "Piso2 Dto.4",<br />        "C1070AAM", "Capital Federal",<br />        "ARGENTINA");<br />    System.out.println(shippingAddress);<br />  }<br /><br /></pre><br />The test prints the following output:<br /><br /><pre style="background: #f0f0f0; border: 1px dashed #cccccc; color: black; font-family: &quot;arial&quot;; font-size: 12px; height: auto; line-height: 20px; overflow: auto; padding: 0px; text-align: left; width: 99%;"><code style="color: black; word-wrap: normal;"> Name: FITBIT  <br /> Address1: ONE MARINA PARK DRIVE  <br /> Address2: SUITE 701  <br /> City: BOSTON  <br /> State: MA  <br /> Zip: 02210  <br /> Country: United States  <br /><br /><br /> Name: Mr. Address Argentine  <br /> Address1: Piedras No 623  <br /> Address2: null  <br /> City: Piso2 Dto.4  <br /> State: C1070AAM  <br /> Zip: Capital Federal  <br /> Country: ARGENTINA  <br /></code></pre><br />... With ARGENTINA, the Zip and the State value was transposed!<br /><br /><br />Want to take a look at the sample code listed in full? You can find it on my GitHub site at <a href="https://github.com/tjmaher/Address_Telescoping_Constructors/blob/master/src/test/java/Address.java">https://github.com/tjmaher/Address_Telescoping_Constructors/blob/master/src/test/java/Address.java</a>. <br /><h2>Introducing the Builder Pattern </h2><br />Back in 2008, in his book <b>Effective Java,</b> ( <a href="http://www.amazon.com/Effective-Java-2nd-Joshua-Bloch/dp/0321356683/">Amazon link</a> ) Joshua Block recognized these two problems.<br /><br />He expanded on the <i>Builder pattern</i>, a software design pattern discussed in the Gang of Four's <a href="http://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612">Design Patterns: Elements of Reusable Object-Oriented Software</a> which addresses these concerns. <br /><blockquote>"Traditionally, programmers have used the telescoping constructor pattern, in which you provide a constructor with only the required parameters, another with a single optional parameter, a third with two optional parameters, and so on, culminating in a constructor with all the optional parameters [...] <br /><br />"[...T]he telescoping constructor pattern works, but it is hard to write client code when there are many parameters, and harder still to read it. The reader is left wondering what all those values mean and must carefully count parameters to find out. Long sequences of identically typed parameters can cause subtle bugs. If the client accidentally reverses two such parameters, the compiler wonâ€™t complain, but the program will misbehave at runtime.<br /><br />"Luckily, there is a third alternative that combines the safety of the telescoping constructor pattern with the readability of the JavaBeans pattern. It is a form of the Builder pattern [Gamma95, p. 97]. Instead of making the desired object directly, the client calls a constructor (or static factory) with all of the required parameters and gets a builder object. Then the client calls setter-like methods on the builder object to set each optional parameter of interest. Finally, the client calls a parameterless build method to generate the object, which is immutable". <br /><i>- From Joshua Bloch's article, <a href="http://www.informit.com/articles/article.aspx?p=1216151&amp;seqNum=2">Creating and Destroying Java Objects</a>, May 16, 2008. </i></blockquote><br />What if we could set an address like so?:  <br /><pre class="brush: java">Address billingAddress = new Address.Builder(<br />              .setName("Mr. Address Argentine")<br />              .setAddress1("Piedras No 623")<br />              .setCity("Piso2 Dto.4")<br />              .setState("Capital Federal")<br />              .setZip("C1070AAM")<br />              .setCountry("ARGENTINA");<br /><br /></pre><br />In our next blog article, we will be examining <a href="http://www.tjmaher.com/2016/05/addressbuilder-builder-pattern-example.html">how to implement this</a>. <br /><br /><br><br><br /><div class="toc-section" id="toc-section"><b>Examining Builder Patterns:</b><ul><li><b>Part One:</b>&nbsp;<a href="http://www.tjmaher.com/2016/04/why-use-builder-pattern-examples-of.html">Anti-Pattern: Telescoping Constructors</a></li><li><b>Part Two:</b>&nbsp;<a href="http://www.tjmaher.com/2016/05/addressbuilder-builder-pattern-example.html">Investigating Address Builder</a></li><li><b>Source Code:</b>&nbsp;<a href="https://github.com/tjmaher/BuilderPattern_Java/tree/master/BuilderPattern_Java/src/src/test/java/com/tmaher/builderpattern">GitHub, T.J. Maher</a></li></ul></div><br /><br>Until then, Happy Testing!<br /><br />- T.J. Maher<br />Sr. QA Engineer, <br />Fitbit-Boston<br /><br /><i>// QA Engineer since Aug. 1996 <br />// Automation developer for [ 1 ] year and still counting!  </i>