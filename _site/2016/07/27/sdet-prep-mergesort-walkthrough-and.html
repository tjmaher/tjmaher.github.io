<i>This blog post is part of a series as I research how to move from Automation Development to being a&nbsp;<a href="http://www.tjmaher.com/search/label/SDET" target="_blank">Software Developer in Test</a>. These next few posts will deal with&nbsp;<a href="http://www.tjmaher.com/search/label/algorithms" target="_blank">algorithms</a>.</i><br /><i><br /></i>I've often found good technical videos as difficult to find as good documentation, and for the same reasons... they are geared more towards developers who use the technology day-to-day. The last time I used sorting algorithms on a regular basis such as <i>Insertion</i> and <i>Selection Sort</i>, <i>Bubble Sort</i>, <i>Mergesort</i>, and <i>Quicksort</i> was when I was a Comp Sci Major back in the 1990s. I haven't really seen them while I have been an automation developer.<br /><br />Luckily, there is Harvard University's <b>CS50</b> at <a href="https://www.youtube.com/user/cs50tv" target="_blank">https://www.youtube.com/user/cs50tv</a><br /><br />With our <a href="http://www.tjmaher.com/2016/07/sdet-prep-insertion-sort-and-learning.html" target="_blank">last blog post</a>, we covered the sorting algorithm&nbsp;<b>Insertion Sort, </b>good for sorting small amounts, but not very efficient for large amounts. In this blog post, we are going to be covering an algorithm that is faster for larger amounts... though it does take up a bit of space.<br /><br /><h2>Mergesort</h2><br /><b>Mergesort</b> is a "divide-and-conquer" algorithm. According to <a href="https://en.wikipedia.org/wiki/Divide_and_conquer_algorithms" target="_blank">Wikipedia</a>, &nbsp;"In computer science, divide and conquer (D&amp;C) is an algorithm design paradigm based on multi-branched recursion. A divide and conquer algorithm works by recursively breaking down a problem into two or more sub-problems of the same or related type, until these become simple enough to be solved directly. The solutions to the sub-problems are then combined to give a solution to the original problem".<br /><br />Stanford University &nbsp;professor emeritus Donald Knuth -- author of the 1960s saga "<a href="http://www.cs.utsa.edu/~wagner/knuth/" target="_blank">The Art of Computer Programming</a>" -- cites the mathematician and computer scientist John von Neuman as inventing the Mergesort in 1945.<br /><br /><a name='more'></a><br /><br /><b><u>CS50: Mergesort</u></b><br /><i>Rob Bowden, Harvard University</i><br /><iframe allowfullscreen="" frameborder="0" height="315" src="https://www.youtube.com/embed/EeQ8pwjQxTM" width="560"></iframe> <br /><i><a href="https://www.youtube.com/watch?v=EeQ8pwjQxTM" target="_blank">https://www.youtube.com/watch?v=EeQ8pwjQxTM</a>&nbsp;</i><br /><i><br /></i><br /><h2>Examine Merging Sorted Lists</h2><div><br /></div><div>What would be the fastest way to merge two already sorted lists, such as List A: [4, 15, 16, 50] and List B: [8, 23, 42, 108]?&nbsp;Alternating lists? Using every other number?&nbsp;</div><ul><li>Look at the first elements of the list: Which one is smallest? 4? Or 8? ... it's 4, so that can be removed from List A and placed as the first element, the beginning, of a new merged list.&nbsp;</li><li>Look at the first two elements of the new list: List A:&nbsp;[15, 16, 50] and List B:&nbsp;[8, 23, 42, 108].&nbsp; 8 is smaller, so it is removed from List B, and placed as the second element of the new merged list.&nbsp;</li><li>Keep on going until we have nothing left in List A or List B. If one of the list runs out, take everything left on the other list and append it onto the merged list.&nbsp;</li></ul><div>What would we do if everything is in unsorted order?</div><div><br /></div><h3>Examine Working with Unsorted Lists</h3><div><br /></div><div>Let's create a new list: [108, 15, 50, 4, 8, 42, 23, 16]. What would be the fastest way to sort this lists?</div><ul><li>What is the n value? What is the number of items in the list?</li><li>Divide the list down the middle, creating two lists: If n is even, half of the numbers will be in one, and half will be in the other. If n is odd, just place it in either. It doesn't matter.</li><li>For this example, we have List A: [108, 15, 50, 4] and for List B: [8, 42, 23, 16]</li><li>Now, let's divide everything in half again: List A:[108, 15]. List B: [50, 4]. List C: [8, 42], List D: [23, 16]. Is there an odd-man out? Doesn't matter, just place him in a list.&nbsp;</li><li>Divide in half again, until we have one element per list... size = 1. [108] [15] [50] [4] [8] [42] [23] [16].</li></ul><div><br /></div><div>Now, we merge!</div><ul><li>Merge the first two lists: [108] and [15] =&gt; [15, 108]</li><li>Merge the next two lists: [50] and [4] =&gt; [4, 50]&nbsp;</li><li>Merge [8] and [42] =&gt; [8, 42]</li><li>Merge [23] and [16] =&gt; [16, 23]</li></ul><div><br /></div><div>All merged? Run the merge algorithm again!</div><ul><li>[15, 108] and [4, 50]: We can assume that the two lists are sorted. Compare 15 to 4: 4 is removed from the second list added to a new list leaving [15, 108] and [50]. Next, the 15 and 50 is compared.&nbsp;</li><li>Do this pattern again and again until you are down to two final lists. Run the merge again!&nbsp;</li></ul><div><br /></div><div>How fast was this sorting algorithm compared to one such as Insertion sort (which we covered before) in Big-O notation?</div><div><br /></div><div>Big-O:</div><ul><li>O(n log n): Mergesort</li><li>O(n2): Insertion sort (and Bubble sort, and Selection sort, which we will not covered in this blog).&nbsp;</li></ul><div><br /></div><div>Here's what it looks like as a graph:&nbsp;</div><div><br /></div><div><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="background: rgb(255, 255, 255); border: 1px solid rgb(238, 238, 238); box-shadow: rgba(0, 0, 0, 0.0980392) 1px 1px 5px; color: #222222; font-family: Calibri; font-size: 17.6px; line-height: 24.64px; margin-left: auto; margin-right: auto; padding: 5px; position: relative; text-align: center;"><tbody><tr><td><a href="https://4.bp.blogspot.com/-dFqqFZqjFuI/V5S9Z_vKjmI/AAAAAAAALUQ/_rXWyVrJt9wTx7cuqHU2DdgOMRopvi2cwCLcB/s1600/khan.png" imageanchor="1" style="color: #888888; margin-left: auto; margin-right: auto; text-decoration: none;"><img border="0" height="247" src="https://4.bp.blogspot.com/-dFqqFZqjFuI/V5S9Z_vKjmI/AAAAAAAALUQ/_rXWyVrJt9wTx7cuqHU2DdgOMRopvi2cwCLcB/s400/khan.png" style="background: transparent; border: none; box-shadow: rgba(0, 0, 0, 0.0980392) 0px 0px 0px; padding: 0px; position: relative;" width="400" /></a></td></tr><tr><td class="tr-caption" style="font-size: 14.08px;"><i>From Khan Academy,&nbsp;<a href="https://www.khanacademy.org/computing/computer-science/algorithms/merge-sort/a/divide-and-conquer-algorithms" style="color: #888888; text-decoration: none;" target="_blank">Algorithm comparison</a></i></td></tr></tbody></table></div><div><br /></div><div>Need to sort a really big list? This algorithm is the fastest.</div><div><br /></div><div>There are some drawbacks:</div><div><ul><li>Sorting a small list of five (5) elements? Use the Insertion Sort algorithm. It's faster.</li><li>This will take up a lot more space than Bubble Sort. If RAM or Hard Drive space is at a premium, this is not the best solution.&nbsp;</li></ul></div><br /><h2>Coding Mergesort in Java</h2><br />We'll wrap up with sample code taken from Gayle Laakmann McDowell's wonderful book, <a href="https://www.amazon.com/Cracking-Coding-Interview-Programming-Questions" target="_blank">Cracking the Coding Interview</a>, which I have been trying to use as a study guide for the past day or so, referred to me by the Senior Engineering Manager at Fitbit-Boston.<br /><br />Gayle also is author of the site <a href="https://careercup.com/" target="_blank">https://careercup.com/</a>&nbsp;which also covers programming problems that might be asked on interviews.&nbsp;Quoting and using sample code from <i>Chapter 11: Sorting and Searching: Mergesort</i>....<br /><blockquote>"Merge sort divides the array in half, sorts each of those halves, and then merges them back together. Each of those halves has the same sorting algorithm applied to it. Eventually, you are merging just two single-element arrays. It is the "merge" part that does all the heavy lifting.<br /><br />"The merge method operates by copying all the elements from the target array segment into a helper array, keeping track of where the start of the left and right halves should be (helperLeft and helperRight). We then iterate through helper, copying the smaller element from each half into the array. At the end, we copy any remaining elements into the target array."</blockquote><br /><br />Let's walk through Gayle's mergesort solution, after we do a bit of setup.<br /><br />We'll declare an array of integers like above and feed them into a new method, we will call <i>mergesort</i>:<br /><ul><li>int[] initialArray = [108, 15, 50, 4, 8, 42, 23, 16];</li><li>This means that initialArray[0] is 108.&nbsp;initialArray[1] is 15.&nbsp;initialArray[2] is 50.&nbsp;</li><li>initialArray.length is 8.</li><li>The very last integer, since we are starting at index 0 is (initialArray.length - 1).</li><li>We feed the initialArray into mergesort like so: <i>mergesort(initialArray);</i></li></ul><br /><br /><pre class="brush: java">void mergesort(int[] array) {<br />   int[] helper = new int[array.length];<br />   mergesort(array, helper, 0, array.length - 1);<br />}</pre><br /><ul><li>Pass in the integer array into mergesort.</li><li>Declare a new helper integer array.</li><li>Does the array we passed in have a length of eight? Declare the helper array to be of the same length of the array we passed in.&nbsp;</li><li>Pass into an overloaded method of the same name (mergesort) with a new signature.&nbsp;</li><li>We are passing into mergesort the initial array, the empty helper array, the index of the beginning of the array ("0"), and the end of the array (Whatever the length was, subtracting one). Remember, with counting arrays, we start off with "0". &nbsp;</li></ul><br /><pre class="brush: java">void mergesort(int[] array, int[] helper, int low, int high) {<br />   if (low &lt; high) {<br />      int middle = (low + high) / 2;<br />      mergesort(array, helper, low, middle); // Sort left half<br />      mergesort(array, helper, middle+1, high); // Sort right half<br />      merge(array, helper, low, middle, high); // Merge them<br />    }<br />}</pre><br />Let's say this is the first time around:<br /><br /><ul><li>We have the contents of&nbsp;initialArray = [108, 15, 50, 4, 8, 42, 23, 16]</li><li>We have a brand-new blank helper array.&nbsp;</li><li>The "low" is the index of 0. The "high" is the last position, the array length minus one, which is (<i>8 minus 1</i> ) or 7.</li><li>We want to make sure that starting index is less than the ending index. Yes, 0 &gt; 7.&nbsp;</li><li>We then take the low, add the high, and divide by 2 to get the middle and store it as an integer called "middle". 7 plus 0 = 7. Divide by 2, and you get 3 with a remainder. Since we are storing this in an integer, just the "3" is stored as the new middle index.&nbsp;</li></ul><div>Now for recursion... <i>Did you know the definition of recursion is "recursion"?</i>&nbsp;</div><div><br /></div><div>We are splitting the list into two parts:</div><div><ul><li>We are going to feed into one array ([108, 15, 50, 4, 8, 42, 23, 16]), the helper array, the low index of position "0", and the high of the middle position, "3". It'll be looking at [108, 15, 50, 4].</li><li>We are going to feed into the other array the entire list ([108, 15, 50, 4, 8, 42, 23, 16]),&nbsp;the helper array, the middle&nbsp;+1 as the low. ( initialArray[4] is 8 ) and the high of "7". Therefore, it is looking at [8, 42, 23, 16].&nbsp;</li><li>Round and round it will go, dividing in half and half again. Soon, there will be an array where the low is index 0, and the high fed into mergeSort will also be 0... then the program will realize that it has to stop dividing since (low &lt; high) will then fail. You will have "108" be in an array.&nbsp;</li></ul></div><br /><pre class="brush: java">void merge(int[] array, int[] helper, int low, int middle, int high) {<br />    // Copy both halves into a helper array <br />    for (int i = low; i &lt;= high; i++) {<br />          helper[i] = array[i];<br />    }<br />    int helperLeft = low;<br />    int helperRight = middle + 1;<br />    int current = low;<br /><br />// Iterate through helper array. Compare the left and right<br />// half, copying back the smaller element from the two halves<br />// into the original array. <br /> <br />  while (helperLeft &lt;= middle &amp;&amp; helperRight &lt;= high) {<br />   if (helper[helperLeft] &lt;= helper[helperRight]) {<br />   array[current] = helper[helperLeft];<br />   helperLeft++;<br />  } else { // If right element is smaller than left element<br />   array[current] = helperfhelperRight];<br />   helperRight++;<br />  }<br />  current++;<br /> }<br /><br />// Copy the rest of the left side of the array into the<br />// target array <br /><br />  int remaining = middle - helperLeft;<br />  for (int i = 0; i &lt;= remaining; i++) {<br />   array [current + i] = helper[helperLeft + i]j<br />  }<br /> }</pre><br><br>As Gladys lists in her book: <blockquote><i>"You may notice that only the remaining elements from the left half of the helper array are copied into the target array. Why not the right half? The right half doesn't need to be copied because it's already there.<br /><br />"Consider, for example, an array like [lj 4, 5 || 2, 8, 9] (the"| ("indicates the partition point). Prior to merging the two halves, both the helper array and the target array segment will end with [8, 9]. Once we copy over four elements (1, 4, 5, and 2) into the target array, the [8, 9] will still be in place in both arrays. There's no need to copy them over".</i></blockquote><br />Next blog entry, we will continue to use "Cracking the Coding Interview" as a source as we examine Data Structures. <br />Until then, Happy Testing! <br /><br />-T.J. Maher<br />Sr. QA Engineer, <br />Fitbit-Boston<br /><br /><i>// BSCS, MSE, and QA Engineer since Aug. 1996 <br />// Automation developer for [ 1.5 ] years and still counting!<br />// Check out Adventures in Automation and Like us on <a href="https://www.facebook.com/AdventuresInAutomation/">Facebook</a>! </i>