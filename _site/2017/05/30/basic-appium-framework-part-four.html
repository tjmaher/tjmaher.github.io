<i>This is part four of of a seven-part blog series. Care to go&nbsp;<a href="http://www.tjmaher.com/2017/05/basic-appium-framework-part-one.html">back to the beginning</a>?</i><br /><br />Now, let's wrap things up by setting up a few <b>Page Objects</b>, add the <b>Page Factory pattern</b> to these building blocks we are creating, and then compose the test we designed all the way in <a href="http://www.tjmaher.com/2017/05/basic-appium-framework-part-two.html" target="_blank">Part Two</a>.<br /><br /><h3>BeforeSuite and AfterSuite Annotations</h3><br />First things first... Remember how we made in the last chapter installing and launching the app itself the test?<br /><br />Let's change that, placing it in a <b>@BeforeSuite</b> annotation from TestNG.<br /><br /><a name='more'></a><br /><br /><pre style="background: #f0f0f0; border: 1px dashed #cccccc; color: black; font-family: &quot;arial&quot;; font-size: 12px; height: auto; line-height: 20px; overflow: auto; padding: 0px; text-align: left; width: 99%;"><code style="color: black; word-wrap: normal;"> import io.appium.java_client.android.AndroidDriver;  <br /> import io.appium.java_client.remote.MobileCapabilityType;  <br /> import io.appium.java_client.remote.MobilePlatform;  <br /> import org.openqa.selenium.remote.DesiredCapabilities;  <br /> import org.testng.annotations.AfterSuite;  <br /> import org.testng.annotations.BeforeSuite;  <br /> import org.testng.annotations.Test;  <br />   <br /> import utils.*;  <br />   <br /> import java.io.File;  <br /> import java.net.MalformedURLException;  <br /> import java.net.URL;  <br /> import java.util.concurrent.TimeUnit;  <br />   <br /> public class SmokeTest {  <br />   <br />   private static AndroidDriver driver;   <br />   <br />   @BeforeSuite  <br />   public void DesiredCapabilities() throws MalformedURLException {  <br />     final String URL_STRING = "http://127.0.0.1:4723/wd/hub";  <br />   <br />     URL url = new URL(URL_STRING);  <br />   <br />     File app = new File("ApiDemos-debug.apk");  <br />     DesiredCapabilities caps = new DesiredCapabilities();  <br />     caps.setCapability(MobileCapabilityType.DEVICE_NAME, "emulator-5554");  <br />     caps.setCapability(MobileCapabilityType.APP, app.getAbsolutePath());  <br />     caps.setCapability(MobileCapabilityType.PLATFORM_NAME, MobilePlatform.ANDROID);  <br />   <br />     driver = new AndroidDriver(url, caps);  <br />   <br />   }  <br /></code></pre><br />It's the same code we had before, with the same import statements, except we are saying we want to set up the driver before the test suite runs.<br /><br />Let's pair the&nbsp;<b>@BeforeSuite </b>annotation that creates an instance of the Android driver with<b> @AfterSuite </b>that tears down the driver.<br /><br /><pre style="background: #f0f0f0; border: 1px dashed #cccccc; color: black; font-family: &quot;arial&quot;; font-size: 12px; height: auto; line-height: 20px; overflow: auto; padding: 0px; text-align: left; width: 99%;"><code style="color: black; word-wrap: normal;">   @AfterSuite  <br />   public void tearDownAppium() throws Exception {  <br />     System.out.println("\nTearing Down Driver.");  <br />     driver.quit();  <br />   }  <br /></code></pre><br />Frustrated with what Cédric Beust saw as too many limitations with JUnit 3, he created what he thought of as the Next Generation of Java Test Runner Frameworks, with new sets of annotations in what he dubbed <b>TestNG</b>, such as <b>@BeforeSuite</b> and <b>@AfterSuite</b>.<b>&nbsp;</b><br /><br />... JUnit 4 and JUnit5 (used with Java 8) then integrated much of the new functionality into its own test framework, so it really doesn't matter if you use:<br /><br /><ul><li><b>JUnit</b>:&nbsp;<a href="http://junit.org/" target="_blank">http://junit.org/</a></li><li><b>TestNG</b>:&nbsp;<a href="http://testng.org/" target="_blank">http://testng.org/</a></li></ul><br />... JUnit calls its annotations <b>@BeforeClass</b> and <b>@AfterClass </b>... but in my experience, it doesn't really matter. Nowadays, they are pretty interchangeable, but it is good to learn both.<br /><br />Personally, I favor TestNG. Let's say that a more advanced automation developer than I has already crafted a multi-threaded automation framework, ready for me to use, I can then add code such as:<br /><br /><i> &lt;suite name="My suite" parallel="tests" thread-count="20"&gt;  </i><br /><br />... And we then can have twenty tests running in parallel... We can also bundle up tests, setting different tests to use different XML configuration files TestNG then can use.<br /><div><br /></div><div>That appears to be the only difference when it comes to using either TestNG ot JUnit as test runners for automation frameworks.<br /><br />This Before and After blocks separate out code from the main test. Picture twenty tests, all running at the same time. Every single test needs to have an Android driver declared in the beginning, and torn down in the end.&nbsp;</div><h3><br />Constructing the Building Blocks: Page Objects</h3><div></div><div>When we were first sketching out the three pages we were going to interact with in this test, we had the HomeScreenPage, the InnerApiDemosPage, and the LogTextBoxPage. If we created a Java class for each page we would interact with, they would look like:<br /><ul><li><a href="https://github.com/tjmaher/basic_appium_framework/blob/master/src/test/java/pages/HomeScreenPage.java">HomeScreenPage.java</a>: The first screen of the app that displayed</li><li><a href="https://github.com/tjmaher/basic_appium_framework/blob/master/src/test/java/pages/InnerApiDemosPage.java">InnerApiDemosPage.java</a>: The second screen of the app.</li><li><a href="https://github.com/tjmaher/basic_appium_framework/blob/master/src/test/java/pages/LogTextBoxPage.java">LogTextBoxPage.java</a>: The page we really wanted to get to!&nbsp;</li></ul>... Here, we are organizing the code that Appium will use to manipulate the mobile elements on each page into each separate Java class. If a selector value on the Home Screen, such as the value of the button labeled "Text" changes, we could know exactly where to go to make the change for the page.&nbsp;</div><br /><br /><i>"<b>Page Object</b> is a Design Pattern which has become popular in test automation for enhancing test maintenance and reducing code duplication. A page object is an object-oriented class that serves as an interface to a page of your AUT (Application Under Test). The tests then use the methods of this page object class whenever they need to interact with the UI of that page. The benefit is that if the UI changes for the page, the tests themselves don't need to change, only the code within the page object needs to change. Subsequently all changes to support that new UI are located in one place.</i><br /><br /><i>"The Page Object Design Pattern provides the following advantages</i><br /><i><br />"1. There is a clean separation between test code and page specific code such as locators (or their use if you're using a UI Map) and layout.<br /><br />"2. There is a single repository for the services or operations offered by the page rather than having these services scattered throughout the tests.<br /><br />"In both cases this allows any modifications required due to UI changes to all be made in one place. Useful information on this technique can be found on numerous blogs as this 'test design pattern' is becoming widely used. We encourage the reader who wishes to know more to search the internet for blogs on this subject. Many have written on this design pattern and can provide useful tips beyond the scope of this user guide".</i>&nbsp; - <a href="http://www.seleniumhq.org/docs/06_test_design_considerations.jsp" target="_blank">Selenium HQ, Test Design Considerations</a><br /><div><br />With these Page Objects, let's use the <b>PageFactory </b>pattern, as detailed in&nbsp;<a href="https://github.com/SeleniumHQ/selenium/wiki/PageFactory" target="_blank">https://github.com/SeleniumHQ/selenium/wiki/PageFactory</a><br /><br /><pre style="background: #f0f0f0; border: 1px dashed #cccccc; color: black; font-family: &quot;arial&quot;; font-size: 12px; height: auto; line-height: 20px; overflow: auto; padding: 0px; text-align: left; width: 99%;"><code style="color: black; word-wrap: normal;"> public class HomeScreenPage {  <br />   <br />   private AndroidDriver driver;  <br />   <br />   @AndroidFindBy(id = "android:id/action_bar")  <br />   private MobileElement header;  <br />   <br />   @AndroidFindBy(accessibility = "Text")  <br />   private MobileElement textButton;  <br />   <br />   public HomeScreenPage(AndroidDriver driver) {  <br />     this.driver = driver;  <br />     PageFactory.initElements(new AppiumFieldDecorator(driver, 30, TimeUnit.SECONDS), this);  <br />   }  <br />   <br />   public void verifyHeader(){  <br />     System.out.println("HOME_SCREEN_PAGE: Verifying Header appears.");  <br />     WebDriverWait wait = new WebDriverWait(this.driver, 30);  <br />     wait.until(ExpectedConditions.visibilityOf(header));  <br />   }  <br />   <br />   public void selectTextButton(){  <br />     WebDriverWait wait = new WebDriverWait(driver, 30);  <br />     wait.until(ExpectedConditions.elementToBeClickable(this.textButton));  <br />   <br />     System.out.println("HOME_SCREEN_PAGE: Selecting [TEXT] button.\n");  <br />     this.textButton.click();  <br />   }  <br /> }  <br /></code></pre><br />We are creating two public methods that can be used in our main @Test. If someone instantiates this HomeScreenPage, they can use these methods to:<br /><br /><ul><li>Verify the header appears</li><li>Select the button labelled "Text" with Appium using WebDriver's "click" method.&nbsp;</li></ul><div>Remember how we investigate the APIDemos-debug.apk and found the locators of the two mobile elements we are interacting with? We are capturing those values in the private variables "header" and "textButton".&nbsp;</div><div><br /></div><div>Why private? We don't want a test to interact with those mobile elements directly. What if the locators change?&nbsp;</div><div><br /></div><div>We are using an Object Oriented Principal called <b>Encapsulation</b>.&nbsp;</div><br /><i>"Encapsulation in Java is a mechanism of wrapping the data (variables) and code acting on the data (methods) together as a single unit. In encapsulation, the variables of a class will be hidden from other classes, and can be accessed only through the methods of their current class. Therefore, it is also known as data hiding.<br /><br />"To achieve encapsulation in Java −</i><br /><ul><li><i>"Declare the variables of a class as private.</i></li><li><i>"Provide public setter and getter methods to modify and view the variables values".</i></li></ul>- <a href="https://www.tutorialspoint.com/java/java_encapsulation.htm" target="_blank">TutorialsPoint, Java, Encapsulation</a><br /><br /><h3>Creating Constructors</h3>What about the following code? What does it do?<br /><pre style="background: rgb(240, 240, 240); border: 1px dashed rgb(204, 204, 204); font-family: arial; font-size: 12px; height: auto; line-height: 20px; overflow: auto; padding: 0px; width: 646.469px;"><code style="word-wrap: normal;">   public HomeScreenPage(AndroidDriver driver) {  <br />     this.driver = driver;  <br />     PageFactory.initElements(new AppiumFieldDecorator(driver, 30, TimeUnit.SECONDS), this);  <br />   } </code></pre><br />... This is called a <b>constructor</b>.<br /><br /><i>"A class contains constructors that are invoked to create objects from the class blueprint. Constructor declarations look like method declarations—except that they use the name of the class and have no return type". - Oracle's <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/constructors.html" target="_blank">Java Tutorials - Constructors</a></i><br /><br />If in our test we create a new instance of the HomePageScreen and pass an AndroidDriver to it, it will automatically initialize all mobile elements on the page, waiting up to thirty seconds if need be before failing this step.<br /><br />Next, we call AppiumFieldDecorator. It is the "Default decorator for use with PageFactory. Will decorate 1) all of the WebElement fields and 2) List of WebElement that have @AndroidFindBy, @AndroidFindBys, or @iOSFindBy/@iOSFindBys annotation with a proxy that locates the elements using the passed in ElementLocatorFactory".<br /><br />... What does that mean? <b>I honestly have no clue.</b><br /><br />I know that it is part of the <a href="https://sourcemaking.com/design_patterns/decorator" target="_blank">Decorator Design Pattern</a>. <a href="https://www.tutorialspoint.com/design_pattern/decorator_pattern.htm" target="_blank">TutorialsPoint says</a> it "allows a user to add new functionality to an existing object without altering its structure. This type of design pattern comes under structural pattern as this pattern acts as a wrapper to existing class. This pattern creates a decorator class which wraps the original class and provides additional functionality keeping class methods signature intact".<br /><br />... I am guessing it allows the FindBy's, whether of type IOS, Android or Web to be initialized with the same code.<br /><br /><b>Object Oriented Programming Design Patterns</b> have always made my eyes cross, ever since grad school. See&nbsp;<a href="http://www.tjmaher.com/2015/06/meetup-how-to-study-design-patterns.html" target="_blank">http://www.tjmaher.com/2015/06/meetup-how-to-study-design-patterns.html</a> in order to make your head spin.<br /><br />Let's skip over the code walkthrough of the InnerApiDemos page. It looks almost exactly like the HomeScreenPage. That brings us to...<br /><br /><h3>LogTextBoxPage</h3><br /><pre style="background: #f0f0f0; border: 1px dashed #cccccc; color: black; font-family: &quot;arial&quot;; font-size: 12px; height: auto; line-height: 20px; overflow: auto; padding: 0px; text-align: left; width: 99%;"><code style="color: black; word-wrap: normal;"> public class LogTextBoxPage {  <br />   <br />   private AndroidDriver driver;  <br />   <br />   @AndroidFindBy(id = "android:id/action_bar")  <br />   private MobileElement header;  <br />   <br />   @AndroidFindBy(accessibility = "Add")  <br />   private MobileElement addButton;  <br />   <br />   @AndroidFindBy(id = "io.appium.android.apis:id/text")  <br />   private MobileElement panel;  <br />   <br />   public LogTextBoxPage(AndroidDriver driver) {  <br />     this.driver = driver;  <br />     PageFactory.initElements(new AppiumFieldDecorator(driver, 30, TimeUnit.SECONDS), this);  <br />   }  <br />   <br />   public void verifyHeader(){  <br />     System.out.println("LOG_TEXT_BOX_PAGE: Verifying Header appears.");  <br />     WebDriverWait wait = new WebDriverWait(this.driver, 30);  <br />     wait.until(ExpectedConditions.visibilityOf(header));  <br />   }  <br />   <br />   public void selectAddButton(){  <br />     WebDriverWait wait = new WebDriverWait(driver, 30);  <br />     wait.until(ExpectedConditions.elementToBeClickable(this.addButton));  <br />   <br />     System.out.println("LOG_TEXT_BOX_PAGE: Selecting [ADD] button.\n");  <br />     this.addButton.click();  <br />   }  <br />   <br />   public String getPanelText(){  <br />     return this.panel.getText();  <br />   }  <br /> }  <br /></code></pre><br />... Here, we have a new public method, getPanelText. Appium is using Selenium WebDriver's getText() method to grab the text appearing, and return it as a String.<br /><h3><br />Putting Together a Smoke Test&nbsp;</h3>Now that we have all these building blocks constructed, we can put together our first test!<br /><br />We need to add to the BeforeSuite:<br /><br /><pre style="background: #f0f0f0; border: 1px dashed #cccccc; color: black; font-family: &quot;arial&quot;; font-size: 12px; height: auto; line-height: 20px; overflow: auto; padding: 0px; text-align: left; width: 99%;"><code style="color: black; word-wrap: normal;"> public class SmokeTest {  <br />   <br />   private static AndroidDriver driver;  <br />   private HomeScreenPage homeScreen;  <br />   private InnerApiDemosPage innerApiDemoScreen;  <br />   private LogTextBoxPage logTextBoxPage;  <br />   <br />   @BeforeSuite  <br />   public void DesiredCapabilities() throws MalformedURLException {  <br />     final String URL_STRING = "http://127.0.0.1:4723/wd/hub";  <br />   <br />     URL url = new URL(URL_STRING);  <br />   <br />     File app = new File("ApiDemos-debug.apk");  <br />     DesiredCapabilities caps = new DesiredCapabilities();  <br />     caps.setCapability(MobileCapabilityType.DEVICE_NAME, "emulator-5554");  <br />     caps.setCapability(MobileCapabilityType.APP, app.getAbsolutePath());  <br />     caps.setCapability(MobileCapabilityType.PLATFORM_NAME, MobilePlatform.ANDROID);  <br />   <br />     driver = new AndroidDriver(url, caps);  <br />     homeScreen = new HomeScreenPage(driver);  <br />     innerApiDemoScreen = new InnerApiDemosPage(driver);  <br />     logTextBoxPage = new LogTextBoxPage(driver);  <br />   }  <br />   <br /></code></pre><br />... We are declaring the three Page Objects, then declaring three new instances, placing them in their respective page object variables, <i>homescreen, innerApiDemosScreen</i>, and <i>logTextBoxPage</i>. They are now all ready to be used for our test!<br /><br /><pre style="background: #f0f0f0; border: 1px dashed #cccccc; color: black; font-family: &quot;arial&quot;; font-size: 12px; height: auto; line-height: 20px; overflow: auto; padding: 0px; text-align: left; width: 99%;"><code style="color: black; word-wrap: normal;"> @Test  <br />   public void test_login() throws Exception {  <br />     driver.manage().timeouts().implicitlyWait(30, TimeUnit.SECONDS);  <br />   <br />     homeScreen.verifyHeader();  <br />     homeScreen.selectTextButton();  <br />   <br />     innerApiDemoScreen.verifyHeader();  <br />     innerApiDemoScreen.selectLogTextBoxButton();  <br />   <br />     logTextBoxPage.verifyHeader();  <br />     logTextBoxPage.selectAddButton();  <br />   <br />     String expectedPanelText = "This is a test";  <br />     String actualPanelText = logTextBoxPage.getPanelText();  <br />   <br />     System.out.println("Checking panel text...");  <br />   <br />     TestUtils.outputIfMatchPassOrFail(expectedPanelText, actualPanelText);  <br />     assertThat(actualPanelText,containsString(expectedPanelText));  <br />   }  <br /></code></pre><br /><br />... After all of the clicking on buttons and verifying the headers load, the true test is:<br /><br /><ul><li>Selecting the Add Button.</li><li>Grabbing the text from the display panel.</li><li>Comparing the actual text with the text we expect.&nbsp;</li><li>Assert that the actual and expected text matches.&nbsp;</li></ul><br />Running the test we get....<br /><br /><pre style="background-color: #f6f8fa; border-radius: 3px; box-sizing: border-box; color: #24292e; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; font-size: 13.6px; font-stretch: normal; line-height: 1.45; margin-bottom: 16px; overflow: auto; padding: 16px; word-wrap: normal;">HOME_SCREEN_PAGE: Verifying Header appears.<br />HOME_SCREEN_PAGE: Selecting [TEXT] button.<br /><br />INNER_API_DEMOS_PAGE: Verifying Header appears.<br />INNER_API_DEMOS_PAGE: Selecting [LogTextBox] button.<br /><br />LOG_TEXT_BOX_PAGE: Verifying Header appears.<br />LOG_TEXT_BOX_PAGE: Selecting [ADD] button.<br /><br />Checking panel text...<br />Verifying Expected Value Matches Actual Value:<br /> * Expected Value: This is a test<br /> * Actual Value: This is a test<br /><br />===&gt; (PASS)<br /><br />Tearing Down Driver.</pre><br />Whew!<br /><br />Next blog post, I will walk you through how to download the source code and run the tests on your local machine.<br /><br /><br /><div><div class="toc-section" id="toc-section"><b>Build a Basic Appium Framework</b><br /><ul><li><b>Part One:</b>&nbsp;<a href="http://www.tjmaher.com/2017/05/basic-appium-framework-part-one.html">Review How to Inspect Mobile Apps with Appium Desktop</a></li><li><b>Part Two:</b>&nbsp;&nbsp;<a href="http://www.tjmaher.com/2017/05/basic-appium-framework-part-two.html" target="_blank">Design a Basic Test, Examining Mobile Elements with Appium Desktop</a></li><li><b>Part Three:</b>&nbsp;&nbsp;<a href="http://www.tjmaher.com/2017/05/build-basic-appium-framework-install.html" target="_blank">Install and Launch an App Using Desired Capabilities</a></li><li><b>Part Four:</b>&nbsp;&nbsp;<a href="http://www.tjmaher.com/2017/05/basic-appium-framework-part-four.html">Set up the Page Objects, Page Factories and Tests</a></li><li><b>Part Five:</b>&nbsp;&nbsp;<a href="http://www.tjmaher.com/2017/05/basic-appium-framework-part-five.html">Download the tests and run them on your own MacBook!</a></li><li><b>Part Six: &nbsp;</b><a href="http://www.tjmaher.com/2017/05/launch-android-emulator.html">How to create and launch an Android emulator from Android Studio</a></li><li><b>Part Seven</b>:&nbsp;<a href="http://www.tjmaher.com/2017/06/behind-the-scenes-install-launch-appium.html" target="_blank">What happens behind the scenes as Appium installs and launches an Android app? Examining and footnoting a log file</a>.</li><li><b>GitHub:&nbsp;</b><a href="https://github.com/tjmaher/basic_appium_framework" target="_blank">Review the source code for the project.</a>&nbsp;</li></ul></div><br />Happy Testing!</div><div><br /></div><br />-T.J. Maher<br /><div><a href="https://twitter.com/tjmaher1" style="color: #1155cc;" target="_blank">Twitter</a>&nbsp;|&nbsp;<a href="https://www.linkedin.com/in/tjmaher1" style="color: #1155cc;" target="_blank">LinkedIn</a>&nbsp;|&nbsp;<a href="https://github.com/tjmaher" style="color: #1155cc;" target="_blank">GitHub</a><br /><br /><i>// Sr. QA Engineer, Software Engineer in Test, Software Tester since 1996.<br />// Contributing Writer for&nbsp;<a href="http://techbeacon.com/contributors/thomas-maher" style="color: #1155cc;" target="_blank">TechBeacon.</a><br />// "Looking to move away from manual QA?&nbsp;Follow&nbsp;<a href="http://www.tjmaher.com/" style="color: #1155cc;" target="_blank">Adventures in Automation</a>&nbsp;on <a href="https://www.facebook.com/AdventuresInAutomation/" target="_blank">Facebook</a>!"</i></div></div>