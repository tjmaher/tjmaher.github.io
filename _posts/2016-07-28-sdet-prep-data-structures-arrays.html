---
layout: post
title: 'SDET Prep: Data Structures: Arrays, Hashmaps and how to implement them in
  Java.'
date: '2016-07-28T20:03:00.002-04:00'
author: T.J. Maher
tags:
- SDET
- data structures
modified_time: '2016-07-31T16:14:11.647-04:00'
thumbnail: https://4.bp.blogspot.com/-wB1vK0txOMI/V5o-CRFO8mI/AAAAAAAALVc/iOcV8VAxVSkr_Yss4Mc1tu9mP82G7Y18ACLcB/s72-c/data.png
blogger_id: tag:blogger.com,1999:blog-3868566217808655382.post-7291875192546067004
blogger_orig_url: http://www.tjmaher.com/2016/07/sdet-prep-data-structures-arrays.html
---

<i>This blog post is part of a series as I research how to move from Automation Development to being a&nbsp;<a href="http://www.tjmaher.com/search/label/SDET" target="_blank">Software Developer in Test</a>. We covered some basic <a href="http://www.tjmaher.com/search/label/algorithms" target="_blank">algorithms</a>, before. These next few posts will deal with <a href="http://www.tjmaher.com/search/label/data%20structures" target="_blank">data structures</a>, illustrating them with Java.&nbsp;</i><br /><i><br /></i>As an <b>automation developer</b>, I've been focusing on browser testing with Selenium WebDriver and Java, being able to draw from my decades of experience testing web applications. When it comes to various data structures, I use arrays, lists, arraylists, and the occasional hashmap in my day-to-day work, but that is about it.<br /><br />A <b>Software Developer in Test</b> (SDET) isn't that far removed from a <b>Software Development Engineer</b> (SDE), relying on data structures and algorithms I once studied as a Computer Sci major back at Bridgewater State. <i>Note: Each link below goes to the respective Harvard University CS50 video, if any.</i><br /><br /><ul><li><b><u>Data Structures</u></b>: <a href="https://youtu.be/7EdaoE46BTI" target="_blank">Arrays</a>, <a href="https://youtu.be/5nsKtQuT6E8" target="_blank">Singly Linked Lists</a>, <a href="https://youtu.be/HmAEzp1taIE" target="_blank">Doubly Linked Lists</a>, <a href="https://youtu.be/mFptHjTT3l8" target="_blank">Binary Trees</a>, <a href="https://youtu.be/9Tp8wHD66lw" target="_blank">Stacks</a>, <a href="https://youtu.be/SLOrrO7DlYo" target="_blank">Queues</a>, ArrayLists, and <a href="https://youtu.be/h2d9b_nEzoA" target="_blank">Hash Tables</a></li><li><b><u>Algorithms</u></b>: Breadth First Search and Depth First Search (not on CS50), <a href="https://youtu.be/5xlIPT1FRcA" target="_blank">Binary Search</a>, <a href="https://youtu.be/DFG-XuyPYUQ" target="_blank">Insertion Sort</a>, <a href="https://youtu.be/EeQ8pwjQxTM" target="_blank">Merge Sort</a>, <a href="https://youtu.be/aQiWF4E8flQ" target="_blank">Quicksort</a>.&nbsp;</li><li><b>Concepts such as</b> <a href="https://youtu.be/VrrnjYgDBEk" target="_blank">Recursion</a>, Bit Manipulation (not on CS50), <a href="https://youtu.be/yOdd3uYC--A" target="_blank">Pointers</a>, <a href="https://youtu.be/ywqB3ZTf8OE" target="_blank">Dynamic Memory Allocation</a>&nbsp;and <a href="https://youtu.be/6RLxPdZ59y0" target="_blank">Structures</a>&nbsp;</li><li><b><u>Design Patterns</u></b> like: Singleton Design Pattern, Factory Design Pattern</li><li><b><u>Storing Memory</u></b>&nbsp;in&nbsp;<a href="https://youtu.be/beqqGIdabrE" target="_blank">Stack</a>&nbsp;vs. Heap</li></ul><br />If you are a manual tester or automated tester and want to shift to software development, Gayle Laakmann McDowell's <a href="https://www.amazon.com/Cracking-Coding-Interview-Programming-Questions" target="_blank">Cracking the Coding Interview</a> is an excellent summation of all terms listed above. It seems to be a good resource for even Senior developers, who may be far removed from college.<br /><br /><a name='more'></a><br /><br />When you are a Software Developer, you are always trying to find the right tool for the job. When we looked at sorting algorithms:<br /><br /><ul><li><b>insertion sort</b> was quite fast for sorting five or less elements, but O(n ^ 2) after that.</li><li><b>mergesort</b> was very quick, O(n log n), but needed a bit of space, O(n), when creating new arrays to do the work. Want it fast, but space be damned? This algorithm might qualify. &nbsp;</li><li><b>quicksort</b>, which we didn't look at yet, is very quick on average, O(n log n), but at its worst can be as bad as insertion sort O(n ^ 2). The good thing it only needs O(log(n)) of space, worse case scenario, no matter how big the set of elements are that need to be sorted.&nbsp;</li></ul><br />See more algorithms at the <a href="http://bigocheatsheet.com/" target="_blank">Big-O Cheatsheet</a>, by Eric Rowell. It also has a selection of the Big-O times of Data Structures.<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="https://4.bp.blogspot.com/-wB1vK0txOMI/V5o-CRFO8mI/AAAAAAAALVc/iOcV8VAxVSkr_Yss4Mc1tu9mP82G7Y18ACLcB/s1600/data.png" imageanchor="1" style="margin-left: 0em; margin-right: 0em;"><img border="0" height="468" src="https://4.bp.blogspot.com/-wB1vK0txOMI/V5o-CRFO8mI/AAAAAAAALVc/iOcV8VAxVSkr_Yss4Mc1tu9mP82G7Y18ACLcB/s640/data.png" width="640" /></a></div><br />Let's go over how to use a few of the data structures, starting with the most basic ones:<br /><br /><br /><h2>Arrays</h2><br />Need a way to store a lot of data right next to each other in memory? Arrays are small identically-sized blocks of space. Only the same data typed can be stored in each slot in memory, such as <b>int</b> or <b>char</b>. If there are <i>n</i> elements, First space is 0. Last space is (<i>n-1)</i>.<br /><br />Java has a built in Array object with methods we can use to manipulate the array.<br /><br /><ul><li>Declare an integer array, setting the values: <i>int[] myArray = { 1, 2, 3, 4, 5 };</i></li><li>Initialize an array of size 5: <i>int[] blankArray = new int[5];</i></li><li>Find the first element: <i>myArray[0]&nbsp;</i></li><li>Print out the array size: <i>System.out.println(myArray.length);</i></li><li>Print the last element of the array:<i> int indexLast = (myArray.length - 1); System.out.println(unsortedArray[indexLast]);</i></li><li>Print the entire array: <i>System.out.println(Arrays.toString(myArray));&nbsp;</i></li><li>Sort the array: <i>Array.sort(myArray)</i></li><li>Search the array using the binary search algorithm: <i>Array.binarySearch(myArray).</i></li></ul><br /><br />If you declared an array of five elements, it will always have five elements, never six. The space is set in stone.<br /><br />You can also have multidimentional arrays, such as playing tic-tac-toe on a board that is 3 by 3. For that we would initialize a 3 x 3 grid of characters, since we would be using either an "X" or an "O":<br /><br /><ul><li>Declare a board:<i> char[][] ticTacToe = new char[3][3];</i></li><li>The top left corner would be the value: <i>ticTacToe[0][0]</i></li><li>The middle space would be the value: <i>ticTacToe[1][1]</i></li><li>The right bottom corner space would be the value: <i>ticTacToe[3][3]</i></li><li>Want to insert an "O" in the middle? <i>ticTacToe[1][1] = 'O'; // Note the single quotes, suitable for single characters</i></li></ul><br />How about setting up a 10 x 10 board of Battleship to track where your ships are: true if they are on the space, false if they are not on the space?<br /><br /><ul><li>Board setup: <i>boolean[][] battleship = new boolean[10][10];</i></li></ul><br />... The idea it is a 10 x 10 array is just an abstraction. It actually is just allocating 100 spaces in memory. But with this data structure we can loop along <i>battleship[x][y]</i>&nbsp;as if it was the grid we imagine.<br /><br /><b>CS50</b>: Introduction to Arrays <i>(using C++ sourcecode)</i>:<br /><iframe allowfullscreen="" frameborder="0" height="315" src="https://www.youtube.com/embed/7mOJN1c1JEo" width="560"></iframe> <br /><a href="https://youtu.be/7mOJN1c1JEo"><i>https://youtu.be/7mOJN1c1JEo</i></a><br /><br /><h2>HashMaps</h2>Let's make up an example of how a HashMap can be used in Java.<br /><br />Take the sentence, "The Quick Brown Fox Jumped Over The Lazy Dog". How many 'A's does it have? 'Q's? 'T's?<br /><br /><ul><li>Let's store the sentence into a String, and make sure that everything is lowercase. Oh, and trim off any whitespace.&nbsp;</li><li>And for this example, let's pretend that everything is either alphanumeric (A thru Z or 0 thru 9) or whitespace, just to make it a bit more simple. We can use the String object method "toLowerCase()" and "trim()".</li></ul><br />Think of a String as a collection of characters. We can convert the String into one long character array by using the method "toCharacterArray()". Then, we can use a foreach loop to go through each character.<br /><br />... But where would we store the totals of each character? We could easily set up an array of 26, one for each letter in the English language, but there might be space not used. This would be pretty inefficient.<br /><br />Let's create a Hashmap called "letters". As we go letter by letter through the String sentence (as a character array) we can:<br /><br /><ul><li>Declare the Hashmap to be of type &lt;Character, Integer&gt;.</li><li>Loop through the entire sentence, character by character.</li></ul>Check the letters hashmap. Does it countain a 'q'?<br /><br /><ul><li>If so, let's get whatever the count is up to, increment it by 1, then store it in an integer called "newValue".</li><li>Let's then put that newValue back in the hashmap, using the character by the key.</li></ul><br />What? No 'q' in the hashmap?<br /><br /><ul><li>Let's put in the letters hashmap the value of "1" in that character key.</li></ul><br />Here's what I just came up with as a solution: <br /><br /><pre class="brush: java">@Test<br />public void test_HashMap(){<br />    String sentence = "The Quick Brown Fox Jumped Over the Lazy Dog"<br />                     .toLowerCase().trim();<br />    HashMap&lt;Character, Integer&gt; letters = new HashMap&lt;Character, Integer&gt;();<br />    for (char character : sentence.toCharArray()){<br />        if (letters.containsKey(character)){<br />            int newValue = letters.get(character) + 1;<br />            letters.put(character, newValue);<br />        } else if (character != ' '){<br />            letters.put(character, 1);<br />        }<br />    }<br />    System.out.println(letters);<br />}<br /></pre><br />If we run the test, we get: <br /><pre style="background: #f0f0f0; border: 1px dashed #cccccc; color: black; font-family: &quot;arial&quot;; font-size: 12px; height: auto; line-height: 20px; overflow: auto; padding: 0px; text-align: left; width: 99%;"><code style="color: black; word-wrap: normal;"> {a=1, b=1, c=1, d=2, e=4, f=1, g=1, h=2, i=1, j=1, k=1, l=1, m=1, n=1, o=4, p=1, q=1, r=2, t=2, u=2, v=1, w=1, x=1, y=1, z=1}  <br /></code></pre><br /><br />That is all we have for now when it comes to Software Development. Happy Testing!<br /><br />-T.J. Maher<br />Sr. QA Engineer, <br />Fitbit-Boston<br /><br /><i>// BSCS, MSE, and QA Engineer since Aug. 1996 <br />// Automation developer for [ 1.5 ] years and still counting!<br />// Check out Adventures in Automation and Like us on <a href="https://www.facebook.com/AdventuresInAutomation/">Facebook</a>! </i>