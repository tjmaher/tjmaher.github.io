---
layout: post
title: 'Builder Pattern: Creating an AddressBuilder'
date: '2016-05-14T04:54:00.001-04:00'
author: T.J. Maher
tags:
- code examples
- Java
- Design Pattern
- Builder Pattern
modified_time: '2016-05-16T14:18:32.861-04:00'
thumbnail: https://1.bp.blogspot.com/-jF9_XTtoocQ/VzbIpK28FtI/AAAAAAAAK_c/cgCqtHs7lPYCZ7sgiBaHFMOA8-n3GMhLgCLcB/s72-c/Builder_UML_class_diagram.png
blogger_id: tag:blogger.com,1999:blog-3868566217808655382.post-937632644379332332
blogger_orig_url: http://www.tjmaher.com/2016/05/addressbuilder-builder-pattern-example.html
---

Earlier, I talked about why software developers would use a Builder Pattern to solve problems such as the bad habit of too many overloaded methods <a href="http://www.tjmaher.com/2016/04/why-use-builder-pattern-examples-of.html" target="_blank">telescoping out of control</a>. With this post, I was going to go over a bit more of what I have found, and give a simple example of an AddressBuilder. <br /><br />Down the road, I was going to test out I could use this pattern to create a ProductBuilder (such as <a href="https://www.fitbit.com/alta" target="_blank">ALTA.BLK.LARGE.US</a>) that I could use at my workplace. <br /><br />Much further down the road, I was going to experiment with creating a TestBuilder, where I could set different test parameters, such as placing a standard shopping cart order with multiple products, set the shipping level, and payment types. <br /><br />... For now, though, I'll stick with attempting to create an AddressBuilder. <br /><a name='more'></a><br /><br /><h2>Sidenote: Fitbit-Boston is hiring!</h2><br />And, yes, if you are a Senior Software Developer in the Boston area, <a href="https://www.fitbit.com/jobs/search#all">Fitbit is hiring like crazy</a> with positions on our eCommerce team, on the Firmware team that builds software for our devices, on our automation tool development team, and on our IOS development team... mention where you saw this link when you apply!<br /><br /><h2>The Gang of Four's Builder Pattern</h2><br />The Builder pattern was first introduced in <a href="http://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612">Design Patterns: Elements of Reusable Object-Oriented Software</a> <i>(1994)</i>, written by the "Gang of Four": <a href="https://twitter.com/ErichGamma">@EricGamma</a>,  Richard Helm, Ralph Johnson and John Vlissides. <br /><br /><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="https://1.bp.blogspot.com/-jF9_XTtoocQ/VzbIpK28FtI/AAAAAAAAK_c/cgCqtHs7lPYCZ7sgiBaHFMOA8-n3GMhLgCLcB/s1600/Builder_UML_class_diagram.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" height="216" src="https://1.bp.blogspot.com/-jF9_XTtoocQ/VzbIpK28FtI/AAAAAAAAK_c/cgCqtHs7lPYCZ7sgiBaHFMOA8-n3GMhLgCLcB/s640/Builder_UML_class_diagram.png" width="640" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;"><i>From <a href="http://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612" target="_blank">Design Patterns: Elements of Reusable Object-Oriented Software</a>.</i></td></tr></tbody></table><br />The purpose of this pattern was to "Separate the construction of a complex object from its representation so that the same construction process can create different representations". There are four parts according to the book:<br /><br /><b>Builder:</b><br /><ul><li>"[...] specifies an abstract interface for creating parts of a Product object".</li></ul><br /><br /><b>ConcreteBuilder</b><br /><ul><li>"[...] constructs and assembles parts of the product by implementing the Builder interface". </li><li>"[...] defines and keeps track of the representation it creates". </li><li>"[...] provides an interface for retrieving the product" </li></ul><br /><br /><b>Director</b><br /><ul><li>"[...] constructs an object using the Builder interface".</li></ul><br /><br /><b> Product</b> <br /><ul><li>"[...] represents the complex object under construction. ConcreteBuilder builds the product's internal representation and defines the process by which it's assembled". </li><li>"[...] includes classes that define the constituent parts, including interfaces for assembling the parts into the final result".  </li></ul>... If you want to read more about Design Patterns, I have <a href="http://www.tjmaher.com/search/label/Design%20Pattern">blogged a bit about them</a>.<br /><br /><h2>Effective Java's Builder Pattern</h2><br />The Builder Pattern was re-introduced in Joshua Bloch's ( <a href="https://twitter.com/joshbloch">@JoshBloch</a> ) guide, <a href="http://www.amazon.com/Effective-Java-2nd-Joshua-Bloch/dp/0321356683">Effective Java</a> (2001). From his blog post, <a href="http://www.informit.com/articles/article.aspx?p=1216151&amp;seqNum=2">Creating and Destroying Java Objects</a>: <br /><blockquote><i>"Instead of making the desired object directly, the client calls a constructor (or static factory) with all of the required parameters and gets a builder object. Then the client calls setter-like methods on the builder object to set each optional parameter of interest. Finally, the client calls a parameterless build method to generate the object, which is immutable. The builder is a static member class [...] of the class it builds."<br /><br />"The Builder pattern is flexible. A single builder can be used to build multiple objects. The parameters of the builder can be tweaked between object creations to vary the objects. The builder can fill in some fields automatically, such as a serial number that automatically increases each time an object is created". </i></blockquote><br /><br />Joshua also mentions that another benefit is that the class is now immutable: Its state, the value of its variables, they won't change after it is created. It's pretty set in concrete.<br /><br /><h2>Proceed With Caution, Though</h2><br />Joshua does urge caution: "The Builder pattern does have disadvantages of its own": <br /><ul><li><b>Performance Cost when Creating Object</b>: "In order to create an object, you must first create its builder. While the cost of creating the builder is unlikely to be noticeable in practice, it could be a problem in some performance-critical situations". </li><li><b>Only If Parameters &gt;= 4</b>: "[T]he Builder pattern is more verbose than the telescoping constructor pattern, so it should be used only if there are enough parameters, say, four or more". </li></ul><br /><h2>Drafting the Address</h2><br />Consider a small sample of the types of addresses you can have:<br /><ul><li>An address with Address Name, Address, City and State, such as: <i>Fitbit-Boston, One Marina Park Drive, Boston, MA</i> , suitable for directions in Google Maps.</li><li>A mailing address, which can add a second line to the address, and includes a zip code, such as <i>Suite 701</i>, and <i>02210</i>.</li><li>An address which also adds the country, such as <i>United States</i>.</li></ul><br />If we were to create this, we would have to use three different constructors. Instead, we will create an Address Builder so that we can assemble the address like so:<br /><ul><li>Address.Builder("Fitbit-Boston", "One Marina Park Drive", "Boston", "MA").build();</li><li>Address.Builder("Fitbit-Boston", "One Marina Park Drive", "Boston", "MA")                 .setAddress2("Suite 701").setZip("02210").build();</li><li>Address.Builder("Fitbit-Boston", "One Marina Park Drive", "Boston", "MA")                 .setAddress2("Suite 701").setZip("02210").setCountry("United States").build();</li></ul>... But now we are getting ahead of ourselves!<br /><br /><h2>Writing the Code</h2><br />First, let's set up the parameters in the class. <br /><br />The Address object, once constructed from the class, will be unchanging. We will use the keyword <b>final</b> when we declare the variable, making it a constant. <br /><br /><b>Address.java</b><br /><pre class="brush: java"> <br />public class Address {<br />    private final String addressName; <br />    private final String address1; <br />    private final String address2; <br />    private final String city; <br />    private final String state;<br />    private final String zip;<br />    private final String country; <br /></pre><br />Next, we are going to set up the ConcreteBuilder type, making this internal class static.<br /><br />According to our Address example above, there are two types of fields: <br /><ul><li>Required, such as Address Name, Address Line 1, City, State</li><li>Optional, such as Address Line 2, Zip Code, and Country</li></ul><br />The optional ones we will save as Strings, but with the required fields, such as Address Name, we will also the keyword <b>final</b>.  <br /><br /><b>Builder</b><br /><pre class="brush: java"> <br />public static class Builder {<br />        // Required Parameters<br />        private final String name;<br />        private final String address1;<br />        private final String city;<br />        private final String state;<br /><br />        // Optional Parameters<br />        private String address2;<br />        private String zip;<br />        private String country;<br />  }<br /></pre><br />Once we figure out which fields are always required, we can create a constructor for the Builder class, to feed the values inputted into the Address' private fields. We do that with the <b>this</b> keyword.<br /><pre class="brush: java"> <br />public Builder(String name, String address1, <br />               String city, String state) {<br />            this.name = name;<br />            this.address1 = address1;<br />            this.city = city;<br />            this.state = state;<br />}<br /></pre><br />Next, we want a way to set up the optional parameters: <br /><pre class="brush: java"> <br />       public Builder setAddress2(String value) {<br />            address2 = value;<br />            return this;<br />        }<br /><br />        public Builder setCountry(String value) {<br />            country = value;<br />            return this;<br />        }<br /><br />        public Builder setZip(String value) {<br />            zip = value;<br />            return this;<br />        }<br /></pre><br />Let's create a method called build to build the object: <br /><pre class="brush: java">    public Address build() {<br />            return new Address(this);<br />        }<br />    }<br /></pre><br />Now, let's create a constructor for Address, and make it private, accessible only to the Builder itself. <br /><pre class="brush: java">private Address(Builder builder) {<br />        this.addressName = builder.name;<br />        this.address1 = builder.address1;<br />        this.city = builder.city;<br />        this.state = builder.state;<br />        this.address2 = builder.address2;<br />        this.country = builder.country;<br />        this.zip = builder.zip;<br />    }<br /></pre>... And there you have it! Our Address and Address Builder is all constructed!<br /><br /><h2>Crafting a Test</h2><br />Now that we created everything... how can we turn this into a test?<br /><br />Let's write a method print out the address we assembled. To keep things neat, let's not print out any blank lines.<br /><br />If there isn't an Address2, or a Zip code, let's not print it out. <br /><br />And, not to get all "meta", but let's use a Builder pattern called StringBuilder to assemble all the pieces of the address. We can create a StringBuilder object, call it "output" and append the values of the String components to the StringBuilder.<br /><br /><pre class="brush: java">    <br />   private StringBuilder appendIfNotBlank(<br />      StringBuilder output, String value ){<br />         if (value != null ){<br />             output.append(value).append("\n");<br />         }<br />         return output;<br />   }<br /></pre>... This method will save us a lot of code duplication, following the software design principle of <b>Don't Repeat Yourself</b> (DRY). <br /><br />Let's override the method we use to print, the <i>toString()</i> method added to every single Java object.  <br /><pre class="brush: java">@Override<br />public String toString(){<br />   StringBuilder output = new StringBuilder();<br />   output.append(this.addressName).append("\n")<br />        .append(this.address1 ).append("\n");<br />   appendIfNotBlank(output, address2);<br />   output.append(this.city).append(", ").append(this.state).append("  ");<br />   appendIfNotBlank(output, this.zip);<br />   appendIfNotBlank(output, this.country);<br />   output.append("\n");<br />   return output.toString();<br />}<br /></pre><br /><br />Last, but not least, let's create a test to:<br /><ul><li>Assemble the new addresses we are creating</li><li>Store them in variables such as <i>fitbitBostonAddress</i> and <i>fitbitBostonMailingAddressWithCountry</i>.</li><li>Print out the new addresses and see what happens!</li></ul><pre class="brush: java">@Test<br />public void test_printUnitedStatesAddresses(){<br />   Address fitbitBostonAddress = new Address.Builder("Fitbit-Boston", <br />       "One Marina Park Drive", "Boston", "MA").build();<br />   Address fitbitBostonMailingAddress = new Address.Builder("Fitbit-Boston", <br />       "One Marina Park Drive", "Boston", "MA")<br />        .setAddress2("Suite 701").setZip("02210").build();<br />   Address fitbitBostonMailingAddressWithCountry = new Address.Builder("Fitbit-Boston", <br />       "One Marina Park Drive", "Boston", "MA")<br />        .setAddress2("Suite 701").setZip("02210").setCountry("United States").build();<br /><br />   System.out.println("Sample Address Formats:\n");<br />   System.out.println(fitbitBostonAddress);<br />   System.out.println(fitbitBostonMailingAddress);<br />   System.out.println(fitbitBostonMailingAddressWithCountry);<br />}<br /></pre><h2>The Moment of Truth</h2><br />When we run the test, we get the following output printed out: <style type="text/css">pre.CICodeFormatter{  font-family:arial;  font-size:12px;  border:1px dashed #CCCCCC;  width:99%;  height:auto;  overflow:auto;  background:#f0f0f0;  line-height:20px;    padding:0px;  color:#000000;  text-align:left; } pre.CICodeFormatter code{  color:#000000;  word-wrap:normal; } </style><br /><pre class="CICodeFormatter"><code class="CICodeFormatter"> [TestNG] Running:  <br />  C:\Users\tmaher\.IdeaIC15\system\temp-testng-customsuite.xml  <br /> Sample Address Formats:  <br />   <br /> Fitbit-Boston  <br /> One Marina Park Drive  <br /> Boston, MA   <br />   <br /> Fitbit-Boston  <br /> One Marina Park Drive  <br /> Suite 701  <br /> Boston, MA 02210  <br />   <br />   <br /> Fitbit-Boston  <br /> One Marina Park Drive  <br /> Suite 701  <br /> Boston, MA 02210  <br /> United States  <br />   <br />   <br /> ===============================================  <br /> Default Suite  <br /> Total tests run: 1, Failures: 0, Skips: 0  <br /> ===============================================  <br /></code></pre><br />Looking for sourcecode you can play around with? You can view it on my GitHub site under <a href="https://github.com/tjmaher/BuilderPattern_Java/tree/master/BuilderPattern_Java/src/src/test/java/com/tmaher/builderpattern">BuilderPattern_Java</a>. <br /><br /><br /><div class="toc-section" id="toc-section"><b>Examining Builder Patterns:</b><br /><ul><li><b>Part One:</b>&nbsp;<a href="http://www.tjmaher.com/2016/04/why-use-builder-pattern-examples-of.html">Anti-Pattern: Telescoping Constructors</a></li><li><b>Part Two:</b>&nbsp;<a href="http://www.tjmaher.com/2016/05/addressbuilder-builder-pattern-example.html">Investigating Address Builder</a></li><li><b>Source Code:</b>&nbsp;<a href="https://github.com/tjmaher/BuilderPattern_Java/tree/master/BuilderPattern_Java/src/src/test/java/com/tmaher/builderpattern">GitHub, T.J. Maher</a></li></ul></div><br /><br /><br />That's it for now! Happy Testing! <br /><br />-T.J. Maher<br />Sr. QA Engineer, <br />Fitbit-Boston<br /><br /><i>// QA Engineer since Aug. 1996 <br />// Automation developer for [ 1 ] year and still counting!</i>